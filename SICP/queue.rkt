#lang sicp
(define front-ptr car)
(define rear-ptr cdr)
(define set-front-ptr! set-car!)
(define set-rear-ptr! set-cdr!)
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (front queue)
  (if (empty-queue? queue)
      (error "Queue is empty." queue)
      (car (front-ptr queue))
  )
)  
(define (insert-queue! item queue)
  (let((new-pair (cons item nil)))
      (cond ((empty-queue? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! new-pair)
              queue
             )
             (else
              (set-cdr! (rear-ptr queue) new-pair)
              (set-rear-ptr! queue new-pair)
              queue
             )
      )
  )
)
(define (delete-queue! queue)
            (cond ((empty-queue? queue)
                   (error "DELETE! called with an empty queue" queue)
                  )
                  (else
                    (set-front-ptr! queue (cdr front-ptr queue))
                    queue
                  )
             )
)
(define (make-queue)
    (let ((front-ptr nil)
          (rear-ptr nil)
         )
         (define empty-queue? (null? front-ptr))
         (define (set-front-ptr! item) (set! front-ptr item))
         (define (set-rear-ptr! item) (set! rear-ptr item))
         (define (front-queue)  
           (if (empty-queue?) 
               (error "FRONT called with an empty queue") 
               (car front-ptr)
           )
         ) 
         (define (insert-queue! item)
            (cond ((empty-queue?)
                   (let ((init-list (list item)))
                        (set! front-ptr init-list)
                        (set! rear-ptr init-list)
                        front-ptr
                    )
                   )
                  (else
                    (let((new-item (list item)))
                        (set-cdr! rear-ptr new-item)
                        (set! rear-ptr new-item)
                        front-ptr))))
        (define (delete-queue!)
            (cond ((empty-queue?)
                   (error "DELETE! called with an empty queue")
                  )
                  (else
                    (set! front-ptr (cdr front-ptr))
                    front-ptr
                  )
             )
         )
        (define (dispatch m)
            (cond ((eq? m 'insert-queue!) insert-queue!)
                  ((eq? m 'delete-queue!) delete-queue!)
                  ((eq? m 'empty-queue?)  empty-queue?)
                  ((eq? m 'front-queue)   front-queue)
                  (else                   (error "Unknow operation -- DISPATCH" m))
             )
         )
dispatch
     )
)
(define make-time-segment cons)
(define segment-time car)
(define segment-queue cdr)
(define (make-agenda) (list 0))
(define current-time car)
(define set-current-time! set-car!)
(define segments cdr)
(define set-segments! set-cdr!)
(define first-segment cadr)
(define rest-segments cddr)
(define (empty-agenda? agenda) (null? (segments agenda)))
(define (add-to-agenda! time action agenda)
  (define (make-new-segment time action)
    ((make-queue) insert-queue! action)
    (make-time-segment time (make-queue))
  )
  (define (add-to-segments! segments)
    (cond((= (segment-time (car segments)) time)
          (insert-queue! action (segment-queue (car segments)))
         )
         ((or (null? (cdr segments)) (< time (segment-time (cadr segments))))
          (set-cdr! segments (cons (make-new-segment time action) (cdr segments)))
         ) 
         (else (add-to-segments! (cdr segments)))
    )
  )
  (if (or (null? (segments agenda)) (< time (segment-time (first-segment agenda))))
      (set-segments! agenda (cons (make-new-segment time action) (segments agenda)))
      (add-to-segments! (segments agenda))
  )
)
(define (remove-first-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
       (delete-queue! q)
       (if (empty-queue? q)
           (set-segments! agenda (rest-segments agenda))
       )
  )
)
(define (first-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty")
      (begin (set-current-time! agenda (segment-time (first-segment agenda)))
             (front (segment-queue (first-segment agenda)))
      )
  )
)  
      
      
          
        
    
    
